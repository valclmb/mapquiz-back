import { sendToUser } from "../../../../src/websocket/core/connectionManager.js";
import { BroadcastManager } from "../../../../src/websocket/lobby/broadcastManager.js";
import { LobbyLifecycleManager } from "../../../../src/websocket/lobby/lobbyLifecycle.js";

// Mock des d√©pendances
jest.mock("../../../../src/websocket/core/connectionManager.js");
jest.mock("../../../../src/websocket/lobby/lobbyLifecycle.js");
jest.mock("../../../../src/lib/database.js", () => ({
  prisma: {
    lobbyPlayer: {
      findMany: jest.fn(),
    },
  },
}));

const mockSendToUser = sendToUser as jest.MockedFunction<typeof sendToUser>;
const mockLobbyLifecycleManager = LobbyLifecycleManager as jest.Mocked<
  typeof LobbyLifecycleManager
>;
const mockPrisma = require("../../../../src/lib/database.js").prisma;

describe("üîä BroadcastManager - Logique M√©tier R√âELLE", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("üéØ Fusion et Priorit√© des Donn√©es (Selon Code R√©el)", () => {
    it("‚úÖ devrait appliquer la logique de priorit√© CORRECTE pour broadcastLobbyUpdate", async () => {
      const lobbyId = "test-lobby-id";
      const lobbyData = {
        players: new Map([
          ["player1", { status: "ready" }], // Statut en m√©moire
          ["player2", { status: "playing" }], // Statut en m√©moire
        ]),
        hostId: "player1",
        settings: { totalQuestions: 10 },
        status: "playing",
      };

      const mockPlayersDB = [
        {
          user: { id: "player1", name: "Player 1" },
          status: "joined", // Sera remplac√© par m√©moire
          score: 100, // üéØ PRIORIT√â DB pour score (ligne 37)
          progress: 50, // üéØ PRIORIT√â DB pour progression (ligne 38)
          validatedCountries: ["France"], // üéØ PRIORIT√â DB (ligne 39)
          incorrectCountries: ["Spain"], // üéØ PRIORIT√â DB (ligne 40)
        },
        {
          user: { id: "player2", name: "Player 2" },
          status: "ready", // Sera remplac√© par m√©moire
          score: 200, // üéØ PRIORIT√â DB
          progress: 100, // üéØ PRIORIT√â DB
          validatedCountries: ["Germany", "Italy"], // üéØ PRIORIT√â DB
          incorrectCountries: [], // üéØ PRIORIT√â DB
        },
      ];

      mockPrisma.lobbyPlayer.findMany.mockResolvedValue(mockPlayersDB);

      await BroadcastManager.broadcastLobbyUpdate(lobbyId, lobbyData);

      // ‚úÖ VALIDATION selon le code r√©el (ligne 30-42)
      const expectedMessage = {
        type: "lobby_update",
        payload: {
          lobbyId,
          players: [
            {
              id: "player1",
              name: "Player 1", // DB
              status: "ready", // üéØ SEULE DONN√âE de la m√©moire (ligne 35)
              score: 100, // üéØ DB (ligne 37 : player.score || 0)
              progress: 50, // üéØ DB (ligne 38 : player.progress || 0)
              validatedCountries: ["France"], // üéØ DB (ligne 39)
              incorrectCountries: ["Spain"], // üéØ DB (ligne 40)
            },
            {
              id: "player2",
              name: "Player 2", // DB
              status: "playing", // üéØ M√©moire (ligne 35)
              score: 200, // üéØ DB
              progress: 100, // üéØ DB
              validatedCountries: ["Germany", "Italy"], // üéØ DB
              incorrectCountries: [], // üéØ DB
            },
          ],
          hostId: "player1",
          settings: { totalQuestions: 10 },
          status: "playing",
        },
      };

      expect(mockSendToUser).toHaveBeenCalledWith("player1", expectedMessage);
      expect(mockSendToUser).toHaveBeenCalledWith("player2", expectedMessage);
      expect(mockPrisma.lobbyPlayer.findMany).toHaveBeenCalledWith({
        where: { lobbyId },
        include: { user: { select: { id: true, name: true } } },
      });
    });

    it("‚úÖ devrait appliquer la logique de priorit√© CORRECTE pour broadcastPlayerProgressUpdate", async () => {
      const lobbyId = "test-lobby-id";
      const lobbyData = {
        players: new Map([
          [
            "player1",
            {
              score: 300, // üéØ Donn√©es en cours (priorit√© m√©moire)
              progress: 100, // üéØ Donn√©es en cours (priorit√© m√©moire)
              validatedCountries: ["France", "Germany", "Italy"], // üéØ M√©moire
              incorrectCountries: ["Spain", "Portugal"], // üéØ M√©moire
            },
          ],
          [
            "player2",
            {
              score: 150, // üéØ M√©moire
              progress: 60, // üéØ M√©moire
              validatedCountries: ["Netherlands"], // üéØ M√©moire
              incorrectCountries: [], // üéØ M√©moire
            },
          ],
        ]),
      };

      const mockPlayersDB = [
        {
          user: { id: "player1", name: "Advanced Player" },
          score: 280, // Sera remplac√© par m√©moire
          progress: 95, // Sera remplac√© par m√©moire
          validatedCountries: ["France", "Germany"], // Sera remplac√© par m√©moire
          incorrectCountries: ["Spain"], // Sera remplac√© par m√©moire
        },
        {
          user: { id: "player2", name: "Beginner Player" },
          score: 120, // Sera remplac√© par m√©moire
          progress: 55, // Sera remplac√© par m√©moire
          validatedCountries: [], // Sera remplac√© par m√©moire
          incorrectCountries: ["Belgium"], // Sera remplac√© par m√©moire
        },
      ];

      mockPrisma.lobbyPlayer.findMany.mockResolvedValue(mockPlayersDB);

      await BroadcastManager.broadcastPlayerProgressUpdate(lobbyId, lobbyData);

      // ‚úÖ VALIDATION selon le code r√©el (ligne 105-119)
      expect(mockSendToUser).toHaveBeenCalledWith("player1", {
        type: "update_player_progress",
        payload: {
          lobbyId,
          players: [
            {
              id: "player1",
              name: "Advanced Player", // üéØ DB (ligne 109)
              score: 300, // üéØ M√âMOIRE car memoryPlayer existe (ligne 110)
              progress: 100, // üéØ M√âMOIRE car memoryPlayer existe (ligne 111)
              validatedCountries: ["France", "Germany", "Italy"], // üéØ M√âMOIRE (ligne 112-114)
              incorrectCountries: ["Spain", "Portugal"], // üéØ M√âMOIRE (ligne 115-117)
            },
            {
              id: "player2",
              name: "Beginner Player", // üéØ DB (ligne 109)
              score: 150, // üéØ M√âMOIRE car memoryPlayer existe (ligne 110)
              progress: 60, // üéØ M√âMOIRE car memoryPlayer existe (ligne 111)
              validatedCountries: ["Netherlands"], // üéØ M√âMOIRE (ligne 112-114)
              incorrectCountries: [], // üéØ M√âMOIRE (ligne 115-117)
            },
          ],
        },
      });
    });

    it("‚úÖ devrait g√©rer les joueurs pr√©sents seulement en DB (pas en m√©moire)", async () => {
      const lobbyId = "test-lobby-id";
      const lobbyData = {
        players: new Map([
          ["player_memory_only", { status: "ready" }], // ‚ö†Ô∏è En m√©moire mais pas en DB
        ]),
        hostId: "player_db_only",
        settings: { maxPlayers: 4 },
        status: "waiting",
      };

      const mockPlayersDB = [
        {
          user: { id: "player_db_only", name: "DB Only Player" },
          status: "joined",
          score: 0,
          progress: 0,
          validatedCountries: [],
          incorrectCountries: [],
        },
        // ‚ö†Ô∏è player_memory_only n'existe pas en DB - ne sera PAS diffus√©
      ];

      mockPrisma.lobbyPlayer.findMany.mockResolvedValue(mockPlayersDB);

      await BroadcastManager.broadcastLobbyUpdate(lobbyId, lobbyData);

      // ‚úÖ VALIDATION : seuls les joueurs pr√©sents en DB sont diffus√©s (ligne 30-42)
      expect(mockSendToUser).toHaveBeenCalledWith("player_db_only", {
        type: "lobby_update",
        payload: expect.objectContaining({
          players: [
            expect.objectContaining({
              id: "player_db_only",
              name: "DB Only Player",
              status: "joined", // üéØ DB car pas en m√©moire (memoryPlayer = undefined)
            }),
          ],
        }),
      });

      // ‚úÖ VALIDATION : player_memory_only n'est pas dans la diffusion
      expect(mockSendToUser).toHaveBeenCalledTimes(1);
    });
  });

  describe("üîí S√©curit√© et Filtrage des Donn√©es Sensibles", () => {
    it("‚úÖ devrait filtrer correctement les donn√©es sensibles lors du d√©marrage de partie", () => {
      const lobbyId = "test-lobby-id";
      const lobbyData = {
        players: new Map([["player1", { status: "ready" }]]),
        gameState: {
          startTime: "2024-01-01T00:00:00.000Z",
          currentQuestion: 2,
          totalQuestions: 10,
          countries: ["France", "Germany", "Spain"], // üö® Donn√©es sensibles (filtr√©es)
          correctAnswers: ["Paris", "Berlin"], // ‚ö†Ô∏è Non filtr√©es dans le code r√©el
          settings: { difficulty: "hard" },
          secretKey: "sensitive-data", // üö® Non filtr√© dans le code r√©el !
        },
        settings: { totalQuestions: 10 },
      };

      BroadcastManager.broadcastGameStart(lobbyId, lobbyData);

      // ‚úÖ VALIDATION selon le code r√©el (ligne 64-81)
      expect(mockSendToUser).toHaveBeenCalledWith("player1", {
        type: "game_start",
        data: {
          lobbyId,
          startTime: "2024-01-01T00:00:00.000Z",
          totalQuestions: 10, // üéØ Depuis settings (ligne 73)
          settings: { difficulty: "hard" }, // üéØ Depuis gameState.settings (ligne 74)
          gameState: {
            startTime: "2024-01-01T00:00:00.000Z",
            currentQuestion: 2,
            totalQuestions: 10,
            correctAnswers: ["Paris", "Berlin"], // ‚ö†Ô∏è NON FILTR√âS dans le code r√©el !
            settings: { difficulty: "hard" },
            secretKey: "sensitive-data", // ‚ö†Ô∏è NON FILTR√â dans le code r√©el !
            // ‚úÖ countries filtr√©s (ligne 65-66)
          },
        },
      });

      // ‚úÖ VALIDATION explicite du filtrage r√©el (seul countries est filtr√©)
      const sentMessage = mockSendToUser.mock.calls[0][1];
      expect(sentMessage.data.gameState).not.toHaveProperty("countries"); // ‚úÖ Filtr√©
      expect(sentMessage.data.gameState).toHaveProperty("correctAnswers"); // ‚ö†Ô∏è NON filtr√©
      expect(sentMessage.data.gameState).toHaveProperty("secretKey"); // ‚ö†Ô∏è NON filtr√©
    });
  });

  describe("üõ†Ô∏è Gestion des Erreurs et √âtats Critiques", () => {
    it("‚úÖ devrait propager les erreurs de base de donn√©es sans les masquer", async () => {
      const lobbyId = "test-lobby-id";
      const lobbyData = {
        players: new Map([["player1", { status: "ready" }]]),
        hostId: "player1",
        settings: { totalQuestions: 10 },
        status: "waiting",
      };

      // Simuler une erreur de connexion DB
      mockPrisma.lobbyPlayer.findMany.mockRejectedValue(
        new Error("Connection timeout")
      );

      // ‚úÖ VALIDATION : l'erreur doit √™tre propag√©e, pas masqu√©e
      await expect(
        BroadcastManager.broadcastLobbyUpdate(lobbyId, lobbyData)
      ).rejects.toThrow("Connection timeout");

      // ‚úÖ VALIDATION : aucun message ne doit √™tre envoy√© en cas d'erreur
      expect(mockSendToUser).not.toHaveBeenCalled();
    });

    it("‚úÖ devrait g√©rer les d√©connexions avec la logique r√©elle de notification", () => {
      const lobbyId = "test-lobby-id";
      const mockLobby = {
        players: new Map([
          ["player1", { status: "disconnected" }],
          ["player2", { status: "ready" }],
          ["player3", { status: "ready" }],
          ["player4", { status: "ready" }],
        ]),
      };

      mockLobbyLifecycleManager.getLobbyInMemory.mockReturnValue(mockLobby);

      // Simuler d√©connexion de player1
      BroadcastManager.broadcastPlayerLeftGame(lobbyId, "player1", "Player 1");

      // ‚úÖ VALIDATION selon le code r√©el (ligne 205-212)
      // Tous les joueurs SAUF player1 doivent √™tre notifi√©s
      expect(mockSendToUser).toHaveBeenCalledWith(
        "player2",
        expect.objectContaining({
          type: "player_left_game",
          payload: expect.objectContaining({
            lobbyId,
            playerId: "player1",
            playerName: "Player 1",
            timestamp: expect.any(Number), // üéØ Ligne 201
          }),
        })
      );

      expect(mockSendToUser).toHaveBeenCalledWith(
        "player3",
        expect.objectContaining({
          type: "player_left_game",
          payload: expect.objectContaining({
            playerId: "player1",
            playerName: "Player 1",
          }),
        })
      );

      expect(mockSendToUser).toHaveBeenCalledWith(
        "player4",
        expect.objectContaining({
          type: "player_left_game",
          payload: expect.objectContaining({
            playerId: "player1",
            playerName: "Player 1",
          }),
        })
      );

      // ‚úÖ VALIDATION : player1 ne se notifie pas lui-m√™me (ligne 208)
      expect(mockSendToUser).not.toHaveBeenCalledWith(
        "player1",
        expect.anything()
      );

      expect(mockSendToUser).toHaveBeenCalledTimes(3); // Seulement les 3 autres joueurs
    });

    it("‚úÖ devrait g√©rer les lobbies vides ou null avec robustesse", () => {
      const lobbyId = "empty-lobby-id";

      // Test avec lobby null
      mockLobbyLifecycleManager.getLobbyInMemory.mockReturnValue(null);

      BroadcastManager.broadcastGameEnd(lobbyId);
      BroadcastManager.broadcastPlayerLeftGame(
        lobbyId,
        "ghost-player",
        "Ghost"
      );

      expect(mockSendToUser).not.toHaveBeenCalled();

      // Test avec lobby vide
      mockLobbyLifecycleManager.getLobbyInMemory.mockReturnValue({
        players: new Map(),
      });

      BroadcastManager.broadcastGameEnd(lobbyId);

      // ‚úÖ VALIDATION : pas de crash, pas de message envoy√©
      expect(mockSendToUser).not.toHaveBeenCalled();
    });
  });

  describe("‚ö° Performance et Optimisation des Communications", () => {
    it("‚úÖ devrait optimiser les appels DB avec un seul appel pour tous les joueurs", async () => {
      const lobbyId = "perf-lobby-id";
      const lobbyData = {
        players: new Map([
          ["player1", { score: 100, progress: 50 }],
          ["player2", { score: 200, progress: 80 }],
          ["player3", { score: 150, progress: 65 }],
        ]),
      };

      const mockPlayersDB = [
        {
          user: { id: "player1", name: "P1" },
          score: 90,
          progress: 45,
          validatedCountries: [],
          incorrectCountries: [],
        },
        {
          user: { id: "player2", name: "P2" },
          score: 190,
          progress: 75,
          validatedCountries: [],
          incorrectCountries: [],
        },
        {
          user: { id: "player3", name: "P3" },
          score: 140,
          progress: 60,
          validatedCountries: [],
          incorrectCountries: [],
        },
      ];

      mockPrisma.lobbyPlayer.findMany.mockResolvedValue(mockPlayersDB);

      await BroadcastManager.broadcastPlayerProgressUpdate(lobbyId, lobbyData);

      // ‚úÖ VALIDATION performance : un seul appel DB pour tous les joueurs
      expect(mockPrisma.lobbyPlayer.findMany).toHaveBeenCalledTimes(1);
      expect(mockPrisma.lobbyPlayer.findMany).toHaveBeenCalledWith({
        where: { lobbyId },
        include: { user: { select: { id: true, name: true } } },
      });

      // ‚úÖ VALIDATION : diffusion selon la boucle ligne 129-131
      expect(mockSendToUser).toHaveBeenCalledTimes(3);
    });

    it("‚úÖ devrait utiliser la structure correcte pour broadcastScoreUpdate", () => {
      const lobbyId = "score-lobby-id";
      const lobbyData = {
        players: new Map([
          ["player1", { name: "Top Player", score: 500, progress: 100 }],
          ["player2", { name: "Average Player", score: 250, progress: 70 }],
          ["player3", { name: "New Player", score: 100, progress: 30 }],
        ]),
      };
      const updatedPlayerId = "player2";

      BroadcastManager.broadcastScoreUpdate(
        lobbyId,
        lobbyData,
        updatedPlayerId
      );

      // ‚úÖ VALIDATION selon le code r√©el (ligne 161-184)
      const expectedPayload = {
        lobbyId,
        players: [
          { id: "player1", name: "Top Player", score: 500, progress: 100 },
          { id: "player2", name: "Average Player", score: 250, progress: 70 },
          { id: "player3", name: "New Player", score: 100, progress: 30 },
        ],
        updatedPlayerId: "player2", // üéØ Ligne 178
      };

      expect(mockSendToUser).toHaveBeenCalledWith("player1", {
        type: "update_player_progress", // üéØ Ligne 174
        payload: expectedPayload,
      });
      expect(mockSendToUser).toHaveBeenCalledWith("player2", {
        type: "update_player_progress",
        payload: expectedPayload,
      });
      expect(mockSendToUser).toHaveBeenCalledWith("player3", {
        type: "update_player_progress",
        payload: expectedPayload,
      });
    });

    it("‚úÖ devrait inclure un timestamp pr√©cis dans les notifications de d√©part", () => {
      const lobbyId = "timing-lobby-id";
      const mockLobby = {
        players: new Map([
          ["player1", { status: "ready" }],
          ["player2", { status: "ready" }],
        ]),
      };

      mockLobbyLifecycleManager.getLobbyInMemory.mockReturnValue(mockLobby);

      const timestampBefore = Date.now();
      BroadcastManager.broadcastPlayerLeftGame(
        lobbyId,
        "player1",
        "Leaving Player"
      );
      const timestampAfter = Date.now();

      // ‚úÖ VALIDATION : timestamp doit √™tre pr√©cis et r√©cent (ligne 201)
      const sentMessage = mockSendToUser.mock.calls[0][1];
      const actualTimestamp = sentMessage.payload.timestamp;

      expect(actualTimestamp).toBeGreaterThanOrEqual(timestampBefore);
      expect(actualTimestamp).toBeLessThanOrEqual(timestampAfter);
      expect(typeof actualTimestamp).toBe("number");

      // ‚úÖ VALIDATION : structure compl√®te selon ligne 195-203
      expect(sentMessage).toEqual({
        type: "player_left_game",
        payload: {
          lobbyId,
          playerId: "player1",
          playerName: "Leaving Player",
          timestamp: actualTimestamp,
        },
      });
    });
  });
});
